#!/usr/bin/env bash

die() {
	echo -e " ${NOCOLOR-\e[1;31m*\e[0m }${*}" >&2
	echo -e " ${NOCOLOR-\e[1;31m*\e[0m }For more information please refer to https://github.com/Biosias/uefi-mkconfig"
	exit 1
}

einfo() {
	echo -e " ${NOCOLOR-\e[1;32m*\e[0m }${*}" >&2
}

ewarn() {
	echo -e " ${NOCOLOR-\e[1;33m*\e[0m }${*}" >&2
}

prepare_entry_label () {

	# Substitute %values in entry labels
	entry_label="${entry_label/\%efi_file_path/${efi_file_path/.uefibackup}}"
	entry_label="${entry_label/\%partition_label/$partition_label}"
	entry_label="${entry_label/\%kernel_version/${kernel_version/-*}}"
	entry_label="${entry_label/\%linux_name/$NAME}"
	entry_label="${entry_label/\%entry_id/$entry_id}"
	entry_label="${entry_label/\%partition/$partition}"

	[[ -n $XEN ]] && entry_label="Xen with $entry_label"

	# Add prefix to entry label for easier identification
	if [[ -n $backup_efi ]]; then
		entry_label="UMCB $entry_label"
	else
		entry_label="UMC $entry_label"
	fi

	[[ $ENTRY_LABEL_LIMIT == 1 ]] && (( $(wc -c <<< "${entry_label}") > 60 )) && die "Entry label length is over 60 characters! Create a shorter one or disable this check through the config file. "

}

prepare_initramfs () {

	# Create path to initramfs
	initramfs_image=
	if [[ -z $kernel_version ]]; then
		# Use versionless initramfs image if the kernel efi file is versionless
		initramfs_image="${efi_file_path/${efi_file_path##*/}}initramfs.img"
	else
		initramfs_image="${efi_file_path/${efi_file_path##*/}}initramfs-$kernel_version.img"
	fi

	# Add .old suffix to initramfs in case we are handling kernel with -old suffix
	[[ "$efi_file_path" == *"-old."* ]] && initramfs_image="${initramfs_image/-old}.old"

	if  [[ -f "$partition_mount$initramfs_image.ignore" ]]; then
		# Ignore chosen initramfs image
		ewarn "Ignoring initramfs image \"$partition_mount$initramfs_image\" of \"$partition_mount$efi_file_path\""
	elif [[ -f "$partition_mount$initramfs_image" ]]; then
		# Check if corresponding initramfs exists
		[[ -z $XEN ]] && entry_kernel_commands="${entry_kernel_commands} initrd=${initramfs_image//\//\\}"
	else
		ewarn "No initramfs found for \"$partition_mount$efi_file_path\"."
	fi

}

prepare_shim () {

	# If shim is present in directory, presume it's used for every kernel in said directory
	using_shim=
	shim="$(find "$partition_mount""${efi_file_path/${efi_file_path##*/}/}" -maxdepth 1 -iname "*shim*.efi")"
	if [[ -n "$shim" ]]; then
		shim="${shim%%.efi*}.efi"
		entry_kernel_commands="${efi_file_path//\//\\} ${entry_kernel_commands}"
		using_shim="using shim \"$shim\" "

		# Set efibootmgr loader to shim from kernel efi file
		efi_loader="$(echo ${shim} | sed 's/\//\\/g')"
	fi

}

prepare_microcode () {

	# Check if microcode image exists
	## microcode image can be ignored the same way as kernel image via .ignore suffix
	local microcode_path
	microcode=
	microcode_path="${efi_file_path/${efi_file_path##*/}}"
	if [[ -f "${partition_mount}${microcode_path}amd-uc.img" ]] && [[ ! -f "${partition_mount}${microcode_path}amd-uc.img.ignore" ]]; then
		if [[ -z $XEN ]]; then
			entry_kernel_commands="${entry_kernel_commands} initrd=${microcode_path//\//\\}amd-uc.img"
		else
			microcode="amd-uc.img"
		fi
	fi
	if [[ -f "${partition_mount}${microcode_path}intel-uc.img" ]] && [[ ! -f "${partition_mount}${microcode_path}intel-uc.img.ignore" ]]; then
		if [[ -z $XEN ]]; then
			entry_kernel_commands="${entry_kernel_commands} initrd=${microcode_path//\//\\}intel-uc.img"
		else
			microcode="intel-uc.img"
		fi
	fi

}

add_uefi_entry () {

	efi_loader="${efi_file_path//\//\\}"

	prepare_entry_label

	prepare_initramfs

	# Strip .uefibackup from efi file path
	[[ "$efi_file_path" == *".uefibackup" ]] && efi_file_path=${efi_file_path//.uefibackup/}

	prepare_shim

	prepare_microcode

	# Clean redundant spaces from the kernel commandline
	entry_kernel_commands="$( echo $entry_kernel_commands | sed -E 's/\ +/ /g' | sed 's/ $//g' )"

    # Use forwardslashes instead of backslashes in the loader section
    if [[ -n ${EFI_LOADER_FORWARDSLASH} ]]; then
        efi_loader="$(echo ${efi_loader} | sed 's/\\/\//g')"
        entry_kernel_commands="$(echo ${entry_kernel_commands} | sed 's/\\/\//g')"

    fi

	einfo "Creating ${msg_backup_efi}UEFI entry \"$bootnum\" for \"$partition_mount$efi_file_path\" ${using_shim}found on \"$partition\""

	# Add new entry
	if [[ -n $DISABLE_CMDLINE ]]; then
		if [[ $UMC_TEST == true ]]; then
			echo "DEBUG: efibootmgr -q $opt_backup_efi -b \"$bootnum\" --disk \"/dev/$partition\" --part \"$partition_id\" --label \"$entry_label\" --loader \"${efi_loader}\""
		else
			efibootmgr -q $opt_backup_efi -b "$bootnum" --disk /dev/"$partition" --part "$partition_id" --label "$entry_label" --loader "${efi_loader}" || die "Failed to add UEFI ${msg_backup_efi}entry for \"$efi_file_path\""
		fi
	else
		if [[ $UMC_TEST == true ]]; then
			echo "DEBUG: efibootmgr -q $opt_backup_efi -b \"$bootnum\" --disk \"/dev/$partition\" --part \"$partition_id\" --label \"$entry_label\" --loader \"${efi_loader}\" -u \"$entry_kernel_commands\""
		else
			efibootmgr -q $opt_backup_efi -b "$bootnum" --disk /dev/"$partition" --part "$partition_id" --label "$entry_label" --loader "${efi_loader}" -u ${entry_kernel_commands} || die "Failed to add UEFI ${msg_backup_efi}entry for \"$efi_file_path\""
		fi
	fi

}

add_xen_uefi_entry () {

	local xen_efi_path
	local xen_efi_file

	# Get path where the Xen efi resides
	xen_efi_path=$( echo "$efi_file_path" | sed s/$efi_file_name//g )

	# Find Xen efi files in the same directory as this kernel image
	xen_efi_file="$( tree --matchdirs -ixvP *xen*.efi ${partition_mount}${xen_efi_path} | grep .efi | head -n1 )"

	prepare_entry_label

	prepare_initramfs

	# Strip .uefibackup from efi file path
	[[ "$efi_file_path" == *".uefibackup" ]] && efi_file_path=${efi_file_path//.uefibackup/}

	prepare_shim

	prepare_microcode

	# Clear kernel command line if it is disabled
	[[ -n $DISABLE_CMDLINE ]] && entry_kernel_commands=

	# Generate config which is loaded by Xen.efi
	local xen_config_file
	xen_config_file="umc-xen-$( echo ${efi_file_path} | sed "s/.*\///g").cfg"

	echo "[global]
default=$NAME

[$NAME]
options=${xen_options}
kernel=$( echo ${efi_file_path} | sed "s/.*\///g")${entry_kernel_commands}
ramdisk=$( echo ${initramfs_image} | sed "s/.*\///g")i
ucode=${microcode}"

	# Prepare xen efi as efi loader
	efi_loader="$( echo "${xen_efi_path}${xen_efi_file}" | sed 's/\//\\/g' )"

	echo "efibootmgr -q ${opt_backup_efi} -b "${bootnum}" --disk /dev/"${partition}" --part "${partition_id}" --label "${entry_label}" --loader "${efi_loader}" -u "cfg=${xen_config_file}""
	#efibootmgr -q ${opt_backup_efi} -b "${bootnum}" --disk /dev/"${partition}" --part "${partition_id}" --label "${entry_label}" --loader "${efi_loader}" -u ${xen_config_file}
}

wipe_xen_configs () {

	local xen_efi_path

	# Get path where the Xen efi resides
	xen_efi_path=$( echo "$efi_file_path" | sed s/$efi_file_name//g )

}

clean_legacy_entries () {
	# Run only if no post 2.0 entries exist
	if [[ "$initial_uefi_state" != *" UMC"* ]]; then
		local IFS=$'\n'
		local entries
		local entry
		entries="$(grep -v -e "BootOrder" -e "Timeout" -e "BootCurrent" <<< "$initial_uefi_state" | grep "$kernel_images")"
		for entry in ${entries}; do
			if [[ "$(printf %d "0x${entry:4:4}" 2> /dev/null)" -gt 255 ]] && [[ "$(printf %d "0x${entry:4:4}" 2> /dev/null)" -lt 513 ]]; then
				if [[ $UMC_TEST == true ]]; then
					echo "DEBUG: efibootmgr -q -B -b \"${entry:4:4}\""
				else
					efibootmgr -q -B -b "${entry:4:4}"
				fi

				ewarn "Removing pre v2.0 legacy entry \"${entry:4:4}\""
			fi
		done
	fi
}

wipe_entries () {
	local initial_uefi_umc_state

	# Get list of all non backup entries made by uefi-mkconfig
	initial_uefi_umc_state="$(printf %s "$initial_uefi_state" | grep " UMC ")"

	local IFS=$'\n'
	for delete_entry in $initial_uefi_umc_state; do
		if [[ $UMC_TEST == true ]]; then
			echo "DEBUG: efibootmgr -q -B -b \"${delete_entry:4:4}\""
		else
			efibootmgr -q -B -b "${delete_entry:4:4}"
		fi
	done
}

load_config () {
	default_label="%entry_id %linux_name Linux %kernel_version"
	local kernel_config_paths
	local kernel_config_path
	local kernel_configs_wip
	local config

	kernel_config_paths="/etc/default
/etc/kernel
/usr/lib/kernel"

	[[ -n "${INSTALLKERNEL_CONF_ROOT}" ]] && kernel_config_paths="${INSTALLKERNEL_CONF_ROOT}
${kernel_config_paths}"

	for kernel_config_path in ${kernel_config_paths}; do
		if [[ -f ${kernel_config_path}/uefi-mkconfig ]]; then
			# Check if found config file is legacy or not
			if [[ "$(grep "KERNEL_CONFIG" "${kernel_config_path}/uefi-mkconfig")" == "" ]]; then
				kernel_configs="${default_label} ; $(tr -s "${IFS}" ' ' <"${kernel_config_path}/uefi-mkconfig")"
				# Turn off label length for legacy config file
				ENTRY_LABEL_LIMIT=0
				ewarn "Using legacy uefi-mkconfig configuration file format!"

			else
				kernel_configs="$(grep "KERNEL_CONFIG" "${kernel_config_path}/uefi-mkconfig" | grep -v "#")"

			fi

			einfo "Using kernel commands from \"${kernel_config_path}/uefi-mkconfig\""

			break
		fi

	done

	if [[ -z ${kernel_configs} ]]; then
		echo '# Add your kernel commandline arguments following ";"
# KERNEL_CONFIG="%entry_id %linux_name Linux %kernel_version ; example=test kernel=test cmdline=test arguments=test"
KERNEL_CONFIG="%entry_id %linux_name Linux %kernel_version ;"

# Turn on to only add efi files of the latest kernel version
ONLY_LATEST=false

# Turn on to reverse order in which entries are added
REVERSE_ORDER=false

# Entry label length limit of 60 characters for better compatibility with UEFI Firmware
# Turn on to disable. Thorough testing is recommended before using entry labels longer than 60 characters
DISABLE_LABEL_LIMIT=false

# Exchange backslashes for forwardslashes in the path to the efi file
# This is fix for some uefi firmwares that have problem with backslashes
EFI_LOADER_FORWARDSLASH=false

# Turn on to not insert any kernel command line into the boot entry whatsoever
# Allows kernel command line to be defined in another way without being overwritten
# Anything written into the KERNEL_CONFIG after the ";" will be ignored
DISABLE_CMDLINE=false' > "/etc/default/uefi-mkconfig"

		die "No configuration found! Creating default one in '/etc/default/uefi-mkconfig'. Don't forget to configure the kernel commandline!"

	else
		# Check if only the latest efi file should be added
		[[ -n $(grep "ONLY_LATEST=true" "${kernel_config_path}/uefi-mkconfig" | grep -v "#") ]] && ONLY_LATEST=1

		# Check if entry label limit is turned off
		[[ -n $(grep "ENTRY_LABEL_LIMIT=false\|DISABLE_LABEL_LIMIT=true" "${kernel_config_path}/uefi-mkconfig" | grep -v "#") ]] && ENTRY_LABEL_LIMIT=0

		# Check if entries should be added in the reverse order
		[[ -n $(grep "REVERS_ORDER=true\|REVERSE_ORDER=true" "${kernel_config_path}/uefi-mkconfig" | grep -v "#") ]] && REVERSE_ORDER=1

		# Check if we should disable the kernel command line
		[[ -n $(grep "DISABLE_CMDLINE=true" "${kernel_config_path}/uefi-mkconfig" | grep -v "#") ]] && DISABLE_CMDLINE=1 && ewarn "Warning! DISABLE_CMDLINE option activated. All entries will be added into the firmware without a kernel command line. System will possibly be un-bootable unless they are configured elsewhere."

		# Check if we should use forwardslashes instead of backslashes
		[[ -n $(grep "EFI_LOADER_FORWARDSLASH=true" "${kernel_config_path}/uefi-mkconfig" | grep -v "#") ]] && EFI_LOADER_FORWARDSLASH=1
	fi

			# Verify if "root=" is present
	if [[ "$kernel_configs" != *"root="* && $DISABLE_CMDLINE -ne 1 ]]; then
	    die "Warning! Kernel command \"root=\" is missing from loaded configuration!
   This option is vital for successfully booting the system! Booting will fail without it!
   If you set kernel commandline via another method, please set DISABLE_CMDLINE=true in your uefi_mkcofing to suppress this check!"
	fi

	local IFS=$'\n'
	for config in ${kernel_configs}; do
		local IFS=' '
		# Verify kernel commands
		for check_config in ${config}; do
			# Strip initrd=* from config file
			if [[ "$check_config" != *"initrd="* ]]; then
			    strip_kernel_commands="$strip_kernel_commands $check_config"
			fi

		done
		local IFS=$'\n'

		kernel_configs_wip="$strip_kernel_commands
$kernel_configs_wip"

		strip_kernel_commands=

	done

	kernel_configs_wip=${kernel_configs_wip//'KERNEL_CONFIG="'}
	kernel_configs=${kernel_configs_wip//\"}
}

findmountpoint() {
    # Find mountpoint in which the kernel image resides
    local mountpoint=
    local realmountpoint=
    local finding_partition=

    local IFS=$'\n'
    for finding_partition in $(printf "%s\n" "$lsblk_initial_state"); do
            mountpoint="$(echo "$finding_partition" | cut -d";" -f2)"

            if [[ "$efi_file" == *"$mountpoint"* ]] && [[ $(echo "$mountpoint" | wc -c) -gt $(echo "$realmountpoint" | wc -c) ]]; then
                    realmountpoint="$mountpoint"

            fi

    done

    echo "$realmountpoint"
}

main () {
    local IFS=$'\n'
	efi_parttype="c12a7328-f81f-11d2-ba4b-00a0c93ec93b"

    uefi_mkconfig_version="3.5"

	# Load mocked-up lsblk output for script testing
	if [[ $UMC_TEST == true ]] && [[ $UMC_MOCK == true ]]; then
		lsblk_initial_state="$(sed "s/ * /;/g" "$UMC_TEST_LSBLK")"
	else
		lsblk_initial_state="$(lsblk -lno NAME,MOUNTPOINT,PARTTYPE,PARTN,UUID,PARTLABEL | grep "$efi_parttype" | sed "s/ * /;/g")"
	fi

	mounted_efi_partitions="$(printf "%s\n" "$lsblk_initial_state" | grep "/")"
	kernel_prefixes="vmlinuz vmlinux- kernel- bzImage zImage"
	kernel_configs=

	# Entry label limit is on by default
	ENTRY_LABEL_LIMIT=1

    # Handle Commandline options
    if [[ -n ${options} ]]; then
        help_message="uefi_mkconfig automatic UEFI entry management script
Version: ${uefi_mkconfig_version}
Installed in: $(which ${0})
Github: https://github.com/Biosias/uefi-mkconfig

Usage: uefi_mkconfig [options]
        --help -h       Print this message
        --version -v    Print only version
        --dry-run -d    Do a dry run without writing any changes to the UEFI Firmware"

        if [[ "${options}" == "--help" ]] || [[ "${options}" == "-h" ]]; then
            echo "${help_message}"
            exit 0

        elif [[ "${options}" == "--version" ]] || [[ "${options}" == "-v" ]]; then
            echo "${help_message}" | grep "Github" -B3
            exit 0

        elif [[ "${options}" == "--dry-run" ]] || [[ "${options}" == "-d" ]]; then
            echo "Running Dry Run mode!"
            UMC_TEST=true

        else
            echo "uefi-mkconfig: unrecognized option '${options}'"
            echo "${help_message}"
            exit 0

        fi

    fi

	einfo "Running uefi-mkconfig..."

    # Run additional checks
	if [[ ${EUID} -ne 0 ]]; then
		die "Please run uefi-mkconfig as root!"

	elif [[ -z $(printf "%s\n" "$mounted_efi_partitions" | cut -d";" -f3) ]]; then
		die "lsblk can't see PARTTYPE!"

	elif [[ -z ${mounted_efi_partitions} ]]; then
		die "No mounted efi partitions!"

	elif [[ ! -x "$(command -v efibootmgr)" ]]; then
		die "Unable to access efibootmgr command!"

	fi

	# Get kernel prefix from os-release
	if [[ -f /etc/os-release ]]; then
		. /etc/os-release
		kernel_prefixes="${kernel_prefixes} ${ID}-"
	elif [[ -f /usr/lib/os-release ]]; then
		. /usr/lib/os-release
		kernel_prefixes="${kernel_prefixes} ${ID}-"
	fi

	# Get kernel prefix from entry-token
	if [[ -f /etc/kernel/entry-token ]]; then
		kernel_prefixes="${kernel_prefixes} $(head -n1 /etc/kernel/entry-token)-"
	elif [[ -f /usr/lib/kernel/entry-token ]]; then
		kernel_prefixes="${kernel_prefixes} $(head -n1 /usr/lib/kernel/entry-token)-"
	fi

	# Get initial state of UEFI entries
	if [[ $UMC_TEST == true ]] && [[ $UMC_MOCK == true ]]; then
		initial_uefi_state="$(cat "$UMC_TEST_EFIBOOTMGR")"
	else
		initial_uefi_state="$(efibootmgr -u)"
	fi

	# Remove pre 2.0 legacy entries
	clean_legacy_entries

	# Wipe all managed entries for regeneration
	wipe_entries

	partition_mounts="$(printf "%s\n" "$mounted_efi_partitions" | cut -d";" -f2)"

	local kernel_images_new=
	local kernel_images_old=

	kernel_images_new="$(find $partition_mounts -type f -name "*.efi" -printf "%f\n" | grep -E ".*(${kernel_prefixes// /\|}).*")"
	kernel_images_old="$(echo "$kernel_images_new" | grep "old.efi")"
	kernel_images_new="$(echo "$kernel_images_new" | grep -v "old.efi")"

    # Check if any kernel images were found
    if [ -z "${kernel_images_old}" ] && [ -z "${kernel_images_new}" ]; then
               die "No efi kernel images found!"
    fi

	# Sort kernel images
	kernel_images="$(sort -uV <<< "$kernel_images_old")
$(sort -uV <<< "$kernel_images_new")"

	# Adding path back to the kernel image
	local partition_efis=
	for kernel_image in $kernel_images; do
	    ## If the variable partition_efis is empty, add initial value
	    if [[ -n ${partition_efis} ]]; then
			# Variable partition_mounts in this case can't be inside of ""
		    partition_efis="${partition_efis}
$(find $partition_mounts -name "$kernel_image")"
		else
		    partition_efis="$(find $partition_mounts -name "$kernel_image")"
		fi
	done

	# Move backup entries to the beginning of the list
	for efi_file in $partition_efis; do
		if [[ -f "${efi_file}.uefibackup" ]]; then
		    partition_efis="${efi_file}.uefibackup
${partition_efis}"
		fi

	done

	load_config

	# If only the latest kernel image shoud be added, remove the rest from the list
	local latest_efi_file
	latest_efi_file=
	if [[ -n ${ONLY_LATEST} ]]; then
	    latest_efi_file="${partition_efis/*\/}"
	fi

	# Skip this kernel version if ignore file is found
	for efi_file in $partition_efis; do
		if [[ -f "$efi_file.ignore" ]]; then
			# Get partition mount
			partition_mount="$(findmountpoint)"
			# Get partition
			partition=$(printf "%s\n" "$mounted_efi_partitions" | grep "$partition_mount;" | cut -d";" -f1)

			ewarn "Ignoring \"$efi_file\" on \"$partition\""
			# Remove ignored efi files from the list
			partition_efis="${partition_efis/"${efi_file}"}"
		fi

		# Make sure only the latest efi file is added from all partitions
		[[ -n ${latest_efi_file} ]] && [[ "${efi_file/*\/}" != "${latest_efi_file//\ }" ]] && partition_efis="${partition_efis/"${efi_file}"}"

	done

	# Revers order in which the entries will be added
	if [[ -n "$REVERSE_ORDER" ]]; then
		local reverse_entries
		reverse_entries=

		for rev_entry in $partition_efis; do
			reverse_entries="$rev_entry $reverse_entries"
		done

		partition_efis="$reverse_entries"

		entry_id=1
	else
		# Get number of entries that will be created to be used as unique entry id
		entry_id=$(($(wc -w <<< "$partition_efis") * ($(wc -l <<< "$kernel_configs")-1)))
	fi

    # Prepare info for every efi file so new uefi entry can be crated for it
	for efi_file in $partition_efis; do

		# Get partition mount
		partition_mount="$(findmountpoint)"

		# Get partition
		partition=$(printf "%s\n" "$mounted_efi_partitions" | grep "$partition_mount;" | cut -d";" -f1)

		# Get efi file name
		efi_file_name="$( echo "$efi_file" | sed "s/.*\///g" )"

		# Get partition label
		partition_label="$(printf "%s\n" "$mounted_efi_partitions" | grep "$partition" | cut -d";" -f6)"
		## In case PARTLABEL isn't set, use UUID
		[[ -z "$partition_label" ]] && partition_label="$(printf "%s\n" "$mounted_efi_partitions" | grep "$partition" | cut -d";" -f5)"

		# Prepare path which will be inserted into efibootmgr
		efi_file_path="${efi_file//$partition_mount}"
		# Get kernel version
		kernel_version=

		## Remove everything before first - to remove any prefixes
		if [[ "$efi_file_name" == *"-"* ]]; then
			kernel_version="${efi_file_name/${efi_file_name%%-*}-/}"
		else
			# Disable kernel_version variable if the kernel efi file is versionless
			kernel_version=
		fi
		## Remove .efi suffix if it exists
		[[ "$kernel_version" == *".efi"* ]] && kernel_version="${kernel_version/.efi*/}"

		# Check for existence of backup entry
		backup_efi=
		local backup_entry
		if [[ "$efi_file" == *".uefibackup" ]]; then
			efi_file="${efi_file/.uefibackup/}"
			backup_entry="$(grep "UMCB ${efi_file_path/.uefibackup} on ${partition_label} " <<< "$initial_uefi_state")"
			if [[ -n "$backup_entry" ]]; then
				einfo "Existing BACKUP UEFI entry \"${backup_entry:4:4}\" for \"${efi_file}\" found on \"${partition}\""
				continue
			fi
			backup_efi=1
		fi

		# Add efi entry for efi file
		for kernel_config in ${kernel_configs}; do

			# Make sure efi_file_path is correct for every iteration
			efi_file_path="${efi_file//$partition_mount}"

			entry_label="${kernel_config/\ \;*}"
			entry_label="${entry_label/\ }"
			config_kernel_commands="${kernel_config/*\ \;}"

			# If bootnum is empty, set it to max ID 0200
			if [[ -z $bootnum ]]; then
				bootnum=512 # 512 is decimal value of 0200
			else
				# If it already has value, convert it to decimal and subtract 1
				bootnum="$(($(printf %d 0x"$bootnum") - 1))"
			fi

			# Find first free hex address smaller than or equal to 0200 for new UEFI boot entry
			while [[ "$(grep -v " UMC " <<< "$initial_uefi_state")" == *"Boot$(printf %04X $bootnum)"* ]]; do
				bootnum=$((bootnum - 1))
				# Die if script exceeds managed range 0200-0100
				[[ $bootnum -lt 256 ]] && die "All Boot IDs within managed range are taken!"
			done

			# Convert chosen entry ID into hex
			bootnum="$(printf %04X $bootnum)"

			# Get partition ID
			partition_id="$(printf "%s\n" "$lsblk_initial_state" | grep "$partition" | cut -d";" -f4)"

			# Prepare parameters for adding new entry
			local opt_backup_efi
			local msg_backup_efi
			if [[ -n $backup_efi ]]; then
				opt_backup_efi="--create-only"
				msg_backup_efi="BACKUP "
			else
				opt_backup_efi="--create"
			fi

			entry_kernel_commands="${config_kernel_commands}"

			# Enable/Disable Xen support
			## NON FUNCTIONAL FOR NOW
			XEN=
			if [[ -n $XEN ]]; then
				add_xen_uefi_entry
			else
				add_uefi_entry
			fi

			# If the order in which entries are added should be is reverse reverse counting of the boot number as well
			if [[ -n $REVERSE_ORDER ]]; then
				entry_id=$((entry_id+1))
			else
				entry_id=$((entry_id-1))
			fi

		done

	done

	einfo "Done"

}

options="${1}"

main
